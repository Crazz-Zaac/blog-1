<!DOCTYPE html><html class="theme-next gemini use-motion" lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><link rel="stylesheet" href="/blog/lib/font-awesome/css/font-awesome.min.css?v=4.7.0"><link rel="stylesheet" href="/blog/css/main.css?v=7.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/blog/images/favicon/apple-touch-icon.png?v=7.2.0"><link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon/favicon-32x32.png?v=7.2.0"><link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon/favicon-16x16.png?v=7.2.0"><link rel="mask-icon" href="/blog/images/favicon/safari_pinned_tab.svg?v=7.2.0" color="#222"><meta name="msapplication-config" content="/blog/images/favicon/browserconfig.xml"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/blog/",scheme:"Gemini",version:"7.2.0",sidebar:{position:"left",display:"post",offset:12,onmobile:!1},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},copycode:{enable:!0,show_result:!1,style:null},fancybox:!1,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},translation:{copy_button:"Copy",copy_success:"Copied",copy_failure:"Copy failed"}}</script><meta name="description" content="Recently, I was looking at some research papers on the join reorderability. To start with, let’s understand what do we mean by “join reorderability” and why it is important.Background KnowledgeHere, w"><meta name="keywords" content="Niu,Yunpeng,NUS,CS,Software,Developer"><meta property="og:type" content="article"><meta property="og:title" content="Literature Review on Join Reorderability"><meta property="og:url" content="https://yunpengn.github.io/blog/2018/12/22/literature-review-join-reorder/index.html"><meta property="og:site_name" content="Yunpeng&#39;s Blog"><meta property="og:description" content="Recently, I was looking at some research papers on the join reorderability. To start with, let’s understand what do we mean by “join reorderability” and why it is important.Background KnowledgeHere, w"><meta property="og:locale" content="en"><meta property="og:image" content="https://yunpengn.github.io/blog/images/join_order_tree.jpg"><meta property="og:image" content="https://yunpengn.github.io/blog/images/join_order_asscom.png"><meta property="og:image" content="https://yunpengn.github.io/blog/images/join_order_TBA.png"><meta property="og:image" content="https://yunpengn.github.io/blog/images/join_order_dp_algo.png"><meta property="og:image" content="https://yunpengn.github.io/blog/images/join_order_CD_A.png"><meta property="og:image" content="https://yunpengn.github.io/blog/images/join_order_CD_B.png"><meta property="og:image" content="https://yunpengn.github.io/blog/images/join_order_CD_C.png"><meta property="og:image" content="https://yunpengn.github.io/blog/images/join_order_canonical_abstraction.png"><meta property="og:image" content="https://yunpengn.github.io/blog/images/join_order_compensation_commutative.png"><meta property="og:image" content="https://yunpengn.github.io/blog/images/join_order_antijoin.png"><meta property="og:image" content="https://yunpengn.github.io/blog/images/join_order_gamma.png"><meta property="og:image" content="https://yunpengn.github.io/blog/images/join_order_ECA_rules.png"><meta property="og:updated_time" content="2019-07-13T09:42:23.413Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Literature Review on Join Reorderability"><meta name="twitter:description" content="Recently, I was looking at some research papers on the join reorderability. To start with, let’s understand what do we mean by “join reorderability” and why it is important.Background KnowledgeHere, w"><meta name="twitter:image" content="https://yunpengn.github.io/blog/images/join_order_tree.jpg"><link rel="alternate" href="/blog/atom.xml" title="Yunpeng's Blog" type="application/atom+xml"><link rel="canonical" href="https://yunpengn.github.io/blog/2018/12/22/literature-review-join-reorder/"><script id="page.configurations">CONFIG.page={sidebar:""}</script><title>Literature Review on Join Reorderability | Yunpeng's Blog</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-92228484-1"></script><script>var host=window.location.hostname;if("localhost"!==host){function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-92228484-1")}</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="en"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/blog/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Yunpeng's Blog</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">Life, coding and everything</p></div><div class="site-nav-toggle"><button aria-label="Toggle navigation bar"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-categories"><a href="/blog/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>Categories</a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a></li><li class="menu-item menu-item-about"><a href="/blog/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>About</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://yunpengn.github.io/blog/blog/2018/12/22/literature-review-join-reorder/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Niu Yunpeng"><meta itemprop="description" content="The world never stops for you."><meta itemprop="image" content="/blog/images/avatar_cropped.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Yunpeng's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Literature Review on Join Reorderability</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2018-12-22 16:24:11" itemprop="dateCreated datePublished" datetime="2018-12-22T16:24:11+08:00">2018-12-22</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">Edited on</span> <time title="Modified: 2019-07-13 17:42:23" itemprop="dateModified" datetime="2019-07-13T17:42:23+08:00">2019-07-13</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/Technical/" itemprop="url" rel="index"><span itemprop="name">Technical</span></a></span> , <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/Technical/Database/" itemprop="url" rel="index"><span itemprop="name">Database</span></a></span> , <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/Technical/Database/SQL/" itemprop="url" rel="index"><span itemprop="name">SQL</span></a></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">Comments: </span><a href="/blog/2018/12/22/literature-review-join-reorder/#comments" itemprop="discussionUrl"><span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/12/22/literature-review-join-reorder/" itemprop="commentCount"></span></a></span><br></div></header><div class="post-body" itemprop="articleBody"><p>Recently, I was looking at some research papers on the join reorderability. To start with, let’s understand what do we mean by <em>“join reorderability”</em> and why it is important.</p><h2 id="Background-Knowledge"><a href="#Background-Knowledge" class="headerlink" title="Background Knowledge"></a>Background Knowledge</h2><p>Here, we are looking at a query optimization problem, specifically join optimization. As mentioned by <a href="http://www.benjaminnevarez.com/2010/06/optimizing-join-orders/" target="_blank" rel="noopener">Benjamin Nevarez</a>, there are two factors in join optimization: <strong>selection of a join order</strong> and <strong>choice of a join algorithm</strong>.</p><p>As stated by Tan Kian Lee’s <a href="https://www.comp.nus.edu.sg/~tankl/cs3223/slides/opr.pdf" target="_blank" rel="noopener">lecture notes</a>, common join algorithms include iteration-based nested loop join <em>(tuple-based, page-based, block-based)</em>, sort-based merge join and partition-based hash join. We should consider a few factors when deciding which algorithm to use: 1) types of the join predicate (equality predicate v.s. non-equality predicate); 2) sizes of the left v.s. right join operand; 3) available buffer space &amp; access methods.</p><p>For a query attempting to join <code>n</code> tables together, we need <code>n - 1</code> individual joins. Apart from the join algorithm applied to each join, we have to decide in which order these <code>n</code> tables should be joined. We could represent such join queries on multiple tables as a tree. The tree could have different shapes, such as left-deep tree, right-deep tree and bushy tree. The 3 types of trees are compared below on an example of joining 4 tables together.</p><img src="/blog/images/join_order_tree.jpg" width="450" title="3 types of join trees"><a id="more"></a><p>For a join on <code>n</code> tables, there could be <code>n!</code> left-deep trees and <code>n!</code> right-deep trees respectively. There could be even more bushy trees, etc. Given so many different join orders, it is important to find an optimal one among them. There are many different algorithms to find the optimal join order: exhaustive, greedy, randomized, transformation, dynamic programming (with pruning).</p><h2 id="Join-Reorderability"><a href="#Join-Reorderability" class="headerlink" title="Join Reorderability"></a>Join Reorderability</h2><p>As illustrated in the last section, we have developed algorithms to find the optimal join order of queries. However, we could meet problems when we try to apply such algorithms on outer joins &amp; anti-joins. This is because such joins do not have the same nice properties of commutativity and assocativitity associativity as inner joins.</p><p>Further, this means our algorithms cannot safely search on the entire space to find an optimal order <em>(i.e. a significant subset of the search space is invalid)</em>. Such dilemma puts us into two questions: 1) which part of the search space is valid? 2) what can we do with the invalid part of the search space?</p><p>Up to now, hopefully the topic has become much clearer to you. In <em>join reorderability</em>, we are trying to figure out “the ability to manipulate the join query to a certain join order”.</p><h2 id="Recent-Researches"><a href="#Recent-Researches" class="headerlink" title="Recent Researches"></a>Recent Researches</h2><p>As follows, I summarize some recent researches on this topic and give my <em>naive</em> literature reviews on them.</p><h3 id="Moerkotte-G-Fender-P-amp-Eich-M-2013-On-the-correct-and-complete-enumeration-of-the-core-search-space-doi-10-1145-2463676-2465314"><a href="#Moerkotte-G-Fender-P-amp-Eich-M-2013-On-the-correct-and-complete-enumeration-of-the-core-search-space-doi-10-1145-2463676-2465314" class="headerlink" title="Moerkotte, G., Fender, P., &amp; Eich, M. (2013). On the correct and complete enumeration of the core search space. doi:10.1145/2463676.2465314"></a>Moerkotte, G., Fender, P., &amp; Eich, M. (2013). On the correct and complete enumeration of the core search space. doi:10.1145/2463676.2465314</h3><p>This paper begins by pointing out two major approaches (bottom-up dynamic programming &amp; top-down memoization) to find optimal join order requires the considered search space to be valid. In other words, this probably only works when we consider inner joins only. Such algorithms could not work on outerjoins, antijoins, semijoins, groupjoins, etc.</p><p>To (partially) solve this problem, this paper presents 3 <em>conflict detectors</em>, <code>CD-A</code>, <code>CD-B</code> &amp; <code>CD-C</code> (all correct, but only <code>CD-C</code> is also complete). It also shows 2 approaches (NEL/EEL &amp; SES/TES) proposed in previous researches are buggy. The authors also propose a desired conflict detector to have the following properties:</p><ul><li>correct: no invalid plans will be included;</li><li>complete: all valid plans will be generated;</li><li>easy to understand and implement;</li><li>flexible:<ul><li><em>null-tolerant:</em> the predicates are not required to reject nulls (opposite to <em>null-intolerant</em>);</li><li><em>complex:</em> the predicates could reference more than 2 relations;</li></ul></li><li>extensible: extend the set of binary operators considered <em>(by a table-driven approach)</em>.</li></ul><p>Then, the paper introduces the <strong>“core search space”</strong>, all valid ordering defined by a set of transformation rules. Notice that based on commutativity and assocativitity, the left &amp; right asscom property is also proposed. A “conflict” means application of such transformations <em>(4 kinds of transformations based on 4 properties: commutativity, associativity, l-asscom &amp; r-asscom)</em> will result in an invalid plan. “Conflict detector” basically tries to find out such “conflict”s.</p><p>If a predicate contained in binary operators do not reference tables from both operands, it is called a <em>degenerate predicate</em>. It is observed that for <em>non-degenerate predicate</em>:</p><ul><li>For left nesting tree: can apply either associativity or l-asscom (but not both); and</li><li>For right nesting tree: can apply either associativity or r-asscom (but not both).</li></ul><img src="/blog/images/join_order_asscom.png" width="300" title="3 basic properties"><p>This observation in fact makes our life much easier. For either left or right nesting tree, we only need to consider one kind of transformation (rather than two kinds). We can further observe we usually at most need to apply commutativity <em>once</em> to each operator. We probably only need to apply associativity, l-asscom, or r-asscom less than once per operator as well. All valid &amp; invalid transformations based on the 3 above properties are summarized in the following tables.</p><img src="/blog/images/join_order_TBA.png" width="450" title="Valid & invalid transformations"><p>From this, we can infer that it is possible to create an algorithm to iterate through the whole search space in finite steps. Thereafter, the authors proposed an algorithm that extends the classical dynamic programming algorithm, as shown below.</p><img src="/blog/images/join_order_dp_algo.png" width="360" title="Pseudocode for DP algorithm"><p>Notice that the procedure above calls a sub-procedure <code>Applicable</code>, which tests whether a certain operator is applicable. Talking about “reorderability”, the rest would discuss how to implement this sub-procedure <code>Applicable</code>.</p><p>We introduce a few terms: syntactic eligibility sets (SES), total eligibility sets (TES). When commutativity does not hold, we want to prevent operators from both sides to communicate with each other. Thus, we further define L-TES and R-TES. By merging tables from either left or right operand, we can eliminate those invalid plans depending on whether l-asscom or r-asscom holds. This introduces the <code>CD-A</code> algorithm, as shown below.</p><img src="/blog/images/join_order_CD_A.png" width="300" title="Pseudocode for CD A"><p>By introducing some <em>conflict rules</em> (CRs), <code>CD-B</code> is proposed as follows.</p><img src="/blog/images/join_order_CD_B.png" width="300" title="Pseudocode for CD B"><p><code>CD-C</code> only improves the CRs.</p><img src="/blog/images/join_order_CD_C.png" width="300" title="Pseudocode for CD C"><h3 id="Rao-J-Pirahesh-H-amp-Zuzarte-C-2004-Canonical-abstraction-for-outerjoin-optimization-doi-10-1145-1007568-1007643"><a href="#Rao-J-Pirahesh-H-amp-Zuzarte-C-2004-Canonical-abstraction-for-outerjoin-optimization-doi-10-1145-1007568-1007643" class="headerlink" title="Rao, J., Pirahesh, H., &amp; Zuzarte, C. (2004). Canonical abstraction for outerjoin optimization. doi:10.1145/1007568.1007643"></a>Rao, J., Pirahesh, H., &amp; Zuzarte, C. (2004). Canonical abstraction for outerjoin optimization. doi:10.1145/1007568.1007643</h3><p>Similar to the previous paper, this paper also recognizes the difficulties in optimizing outerjoins due to the lack of commutativity and assocativitity. The authors believe that a canonical representation of inner joins would be <code>the Cartesian products of all relations, followed by a sequence of selection operations, each applying a conjunct in the join predicates</code>. So can we find a canonical abstraction for outerjoins as well? This outlines the objective of this work.</p><p>The two examples below goes with the following 3 tables, <code>R</code>, <code>T</code> and <code>S</code>.</p><table><thead><tr><th align="center">Table R</th><th align="center">k</th><th align="center">a</th><th align="center">b</th><th align="center">c</th></tr></thead><tbody><tr><td align="center"></td><td align="center">r</td><td align="center">1</td><td align="center">1</td><td align="center">1</td></tr></tbody></table><table><thead><tr><th align="center">Table S</th><th align="center">k</th><th align="center">a</th><th align="center">b</th></tr></thead><tbody><tr><td align="center"></td><td align="center">s</td><td align="center">1</td><td align="center">1</td></tr></tbody></table><table><thead><tr><th align="center">Table T</th><th align="center">k</th><th align="center">a</th><th align="center">c</th></tr></thead><tbody><tr><td align="center">N/A</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr></tbody></table><h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h4><p>1)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S INNER JOIN T ON S.a = T.a</span><br></pre></td></tr></table></figure><p>will result in empty data.</p><p>2)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R LEFT JOIN (1) ON R.b = S.b AND R.c = S.c</span><br></pre></td></tr></table></figure><p>will result in</p><table><thead><tr><th align="center">k</th><th align="center">a</th><th align="center">b</th><th align="center">c</th><th align="center">k</th><th align="center">a</th><th align="center">b</th><th align="center">k</th><th align="center">a</th><th align="center">c</th></tr></thead><tbody><tr><td align="center">r</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr></tbody></table><h4 id="Example-1-reordered"><a href="#Example-1-reordered" class="headerlink" title="Example 1 reordered"></a>Example 1 reordered</h4><p>1)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R LEFT JOIN S ON R.b = S.b</span><br></pre></td></tr></table></figure><p>will result in</p><table><thead><tr><th align="center">k</th><th align="center">a</th><th align="center">b</th><th align="center">c</th><th align="center">k</th><th align="center">a</th><th align="center">b</th></tr></thead><tbody><tr><td align="center">r</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">s</td><td align="center">1</td><td align="center">1</td></tr></tbody></table><p>2)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1) INNER JOIN T S.a = T.a AND R.c = T.c</span><br></pre></td></tr></table></figure><p>will result in empty data.</p><h4 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h4><p>1)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S LEFT JOIN JOIN T ON S.a = T.a</span><br></pre></td></tr></table></figure><p>will result in</p><table><thead><tr><th align="center">k</th><th align="center">a</th><th align="center">b</th><th align="center">k</th><th align="center">a</th><th align="center">c</th></tr></thead><tbody><tr><td align="center">s</td><td align="center">1</td><td align="center">1</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr></tbody></table><p>2)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R LEFT JOIN (1) ON R.a = S.a</span><br></pre></td></tr></table></figure><p>will result in</p><table><thead><tr><th align="center">k</th><th align="center">a</th><th align="center">b</th><th align="center">c</th><th align="center">k</th><th align="center">a</th><th align="center">b</th><th align="center">k</th><th align="center">a</th><th align="center">c</th></tr></thead><tbody><tr><td align="center">r</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">s</td><td align="center">1</td><td align="center">1</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr></tbody></table><h4 id="Example-2-reordered"><a href="#Example-2-reordered" class="headerlink" title="Example 2 reordered"></a>Example 2 reordered</h4><p>1)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R LEFT JOIN JOIN T ON R.a = T.a</span><br></pre></td></tr></table></figure><p>will result in</p><table><thead><tr><th align="center">k</th><th align="center">a</th><th align="center">b</th><th align="center">k</th><th align="center">a</th><th align="center">c</th></tr></thead><tbody><tr><td align="center">s</td><td align="center">1</td><td align="center">1</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr></tbody></table><p>2)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1) LEFT JOIN S ON R.a = S.a and T.a = S.a</span><br></pre></td></tr></table></figure><p>will result in</p><table><thead><tr><th align="center">k</th><th align="center">a</th><th align="center">b</th><th align="center">c</th><th align="center">k</th><th align="center">a</th><th align="center">b</th><th align="center">k</th><th align="center">a</th><th align="center">c</th></tr></thead><tbody><tr><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">s</td><td align="center">1</td><td align="center">1</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr></tbody></table><blockquote><p>Thus, we can see that the re-ordering of both R1 and R2 are invalid.</p></blockquote><p>To solve the problem, this paper proposes a canonical abstraction for queries involving both inner and outer joins by 3 operators: <em>outer Cartesian products</em> × (conventional Cartesian products + if either operand is empty, perform an outer join so that the other side is fully preserved), <em>nullification</em> 𝞴 (for rows that don’t satisfy the nullification predicate <code>P</code>, set their nullified attributes <code>a</code> to <code>null</code>) and <em>best match</em> 𝞫 (a filter for rows in a table such that only those which are not dominated by other rows, and also not all-null themselves are left). Notice that such canonical abstraction would maintain both commutativity and transitivity, after which makes it much easier to find the optimal plan. This abstraction for left outerjoin and inner join is shown as follows.</p><img src="/blog/images/join_order_canonical_abstraction.png" width="350" title="Canonical abstraction for inner join and left outer join"><p>We can easily understand the rationale behind the relation above (we call this representation <em>“bestmatch-nullification representation”</em>, shortened as <code>BNR</code>). Let’s take the left outerjoin for an example. In a left outerjoin, the left operand is the <em>preserving side</em> while the right operand is the <em>null-producing side</em>. Thus, we have to nullify the right operand <code>S</code> with the predicate <code>P</code> (similarly, in an inner join, we need to nullify both operands). To prevent the results from containing spurious tuples, we further apply the best match operator. The image below summarizes some commutative rules for the two compensation operators.</p><img src="/blog/images/join_order_compensation_commutative.png" width="350" title="Commutative rules for compensation operators"><p>Notice that although the nullification operator is not interchangable (commutativity), we can add another nullification operator to short-circuit the ripple effect and fix this.</p><h3 id="TaiNing-W-amp-Chee-Yong-Chan-2018-Improving-Join-Reorderability-with-Compensation-Operators-doi-10-1145-3183713-3183731"><a href="#TaiNing-W-amp-Chee-Yong-Chan-2018-Improving-Join-Reorderability-with-Compensation-Operators-doi-10-1145-3183713-3183731" class="headerlink" title="TaiNing, W., &amp; Chee-Yong, Chan. (2018). Improving Join Reorderability with Compensation Operators. doi:10.1145/3183713.3183731"></a>TaiNing, W., &amp; Chee-Yong, Chan. (2018). Improving Join Reorderability with Compensation Operators. doi:10.1145/3183713.3183731</h3><p>This recent work extends the paper in 2004 by following a similar compensation-based approach (CBA) to solve the join reordering problem. In a simple query, all outerjoin predicates have only one conjunct, must be binary predicate referring to only 2 tables, no Cartesian product, and all predicates are null-intolerant. This paper also provides complete join reorderability for single-sided outerjoin, antijoins. For full outerjoin, the approach in this paper is better than previous work.</p><p>To formalize the notion of complete join reorderability, the join order is modelled as an unordered binary tree, with leaf nodes as the relations and internal nodes as the predicates &amp; join operators. In this definition, the join ordering focuses on the order of all operands rather than the specific join operators used. In other words, to achieve a certain join order, we could possibly change the join operators used. Given a query class <code>C</code> and a set of compensation operators <code>O</code>, <code>C</code> is completely reorderable with respect to <code>O</code> if <code>O</code> can help every query <code>Q</code> in <code>C</code> to reorder to every possible order in <code>JoinOrder(Q)</code>. Thus, this paper further purposes an Enhanced Compensation-based Approach (ECA), to enable reordering support for antijoins (by adding 2 more compensation operators). Specifically, antijoins are rewritten in the following way.</p><img src="/blog/images/join_order_antijoin.png" width="300" title="Rewriting rule for antijoins"><p>The above rule makes sense since the gamme operator basically removes those rows in <code>R1</code> which could otherwise join with some row(s) from <code>R2</code> (notice that a left antijoin basically means <code>R1</code> - <code>R1</code> left semijoin <code>R2</code>; and left semijoin means a projection to only include left operand attributes after a natural join). This two-step approach enables the pruning step to be postponed. The design of ECA has 4 desirable factors:</p><ul><li>The operators must be able to maximize the join reorderability;</li><li>An efficient query plan enumeration algorithm;</li><li>The number of compensation operators should be small;</li><li>There exists efficient implementation to each compensation operator (both SQL level and system native level).</li></ul><p>This paper introduces two new operators 𝞬 and 𝞬* . The first operator 𝞬 removes all tuples where the projection of a certain subset of attributes <code>A</code> is not null. The second operator 𝞬* modifies those tuples not selected by first operator by setting their attributes (excluding those in the subset of attributes to <code>B</code>) and then merge the two parts together. These two operators could be interchanged with conventional join operators as shown in the table below.</p><img src="/blog/images/join_order_gamma.png" width="700" title="The 2 new compensation operators"><p>The above properties in fact lead to more rewriting rules as compared to the original CBA approach. The rules are shown in the table as follows.</p><img src="/blog/images/join_order_ECA_rules.png" width="600" title="The rewriting rules for ECA approach"><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://slideplayer.com/slide/7520334/" target="_blank" rel="noopener">Cost Based Transformation</a></li><li><a href="https://www.comp.nus.edu.sg/~tankl/cs3223/slides/opr.pdf" target="_blank" rel="noopener">NUS CS3223 Lecture Notes - Relational Operators</a></li><li><a href="https://www.comp.nus.edu.sg/~tankl/cs3223/slides/opt.pdf" target="_blank" rel="noopener">NUS CS3223 Lecture Notes - Query Optimizer</a></li><li><a href="http://www.benjaminnevarez.com/2010/06/optimizing-join-orders/" target="_blank" rel="noopener">Optimizing Join Orders</a></li></ul></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>Niu Yunpeng</li><li class="post-copyright-link"><strong>Post link: </strong><a href="https://yunpengn.github.io/blog/2018/12/22/literature-review-join-reorder/" title="Literature Review on Join Reorderability">https://yunpengn.github.io/blog/2018/12/22/literature-review-join-reorder/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-ND</a> unless stating additionally.</li></ul></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/blog/2018/07/27/redis-cluster-partition/" rel="next" title="Redis Cluster & Common Partition Techniques in Distributed Cache"><i class="fa fa-chevron-left"></i> Redis Cluster & Common Partition Techniques in Distributed Cache</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/blog/2019/01/05/relational-operators/" rel="prev" title="Evaluation & Implementation of Relational Operators">Evaluation & Implementation of Relational Operators <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div><div class="comments" id="comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">Table of Contents</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">Overview</li></ul><div class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/blog/images/avatar_cropped.jpg" alt="Niu Yunpeng"><p class="site-author-name" itemprop="name">Niu Yunpeng</p><div class="site-description motion-element" itemprop="description">The world never stops for you.</div></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/blog/archives/"><span class="site-state-item-count">11</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/blog/categories/"><span class="site-state-item-count">8</span> <span class="site-state-item-name">categories</span></a></div></nav><div class="feed-link motion-element"><a href="/blog/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/yunpengn" title="GitHub &rarr; https://github.com/yunpengn" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://www.facebook.com/NeilNiuYunpeng" title="Facebook &rarr; https://www.facebook.com/NeilNiuYunpeng" rel="noopener" target="_blank"><i class="fa fa-fw fa-facebook"></i>Facebook</a> </span><span class="links-of-author-item"><a href="https://sg.linkedin.com/in/yunpeng-niu/en" title="LinkedIn &rarr; https://sg.linkedin.com/in/yunpeng-niu/en" rel="noopener" target="_blank"><i class="fa fa-fw fa-linkedin"></i>LinkedIn</a> </span><span class="links-of-author-item"><a href="https://yunpengn.github.io/" title="Website &rarr; https://yunpengn.github.io/"><i class="fa fa-fw fa-globe"></i>Website</a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/blog/images/cc-by-nc-nd.svg" alt="Creative Commons"></a></div></div></div><div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Background-Knowledge"><span class="nav-number">1.</span> <span class="nav-text">Background Knowledge</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Join-Reorderability"><span class="nav-number">2.</span> <span class="nav-text">Join Reorderability</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Recent-Researches"><span class="nav-number">3.</span> <span class="nav-text">Recent Researches</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Moerkotte-G-Fender-P-amp-Eich-M-2013-On-the-correct-and-complete-enumeration-of-the-core-search-space-doi-10-1145-2463676-2465314"><span class="nav-number">3.1.</span> <span class="nav-text">Moerkotte, G., Fender, P., &amp; Eich, M. (2013). On the correct and complete enumeration of the core search space. doi:10.1145/2463676.2465314</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rao-J-Pirahesh-H-amp-Zuzarte-C-2004-Canonical-abstraction-for-outerjoin-optimization-doi-10-1145-1007568-1007643"><span class="nav-number">3.2.</span> <span class="nav-text">Rao, J., Pirahesh, H., &amp; Zuzarte, C. (2004). Canonical abstraction for outerjoin optimization. doi:10.1145/1007568.1007643</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Example-1"><span class="nav-number">3.2.1.</span> <span class="nav-text">Example 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Example-1-reordered"><span class="nav-number">3.2.2.</span> <span class="nav-text">Example 1 reordered</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Example-2"><span class="nav-number">3.2.3.</span> <span class="nav-text">Example 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Example-2-reordered"><span class="nav-number">3.2.4.</span> <span class="nav-text">Example 2 reordered</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TaiNing-W-amp-Chee-Yong-Chan-2018-Improving-Join-Reorderability-with-Compensation-Operators-doi-10-1145-3183713-3183731"><span class="nav-number">3.3.</span> <span class="nav-text">TaiNing, W., &amp; Chee-Yong, Chan. (2018). Improving Join Reorderability with Compensation Operators. doi:10.1145/3183713.3183731</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#References"><span class="nav-number">4.</span> <span class="nav-text">References</span></a></li></ol></div></div></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2017 – <span itemprop="copyrightYear">2019</span> <span class="with-love" id="animate"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder"><a href="https://yunpengn.github.io/" class="theme-link" rel="author" target="_blank">Niu Yunpeng</a></span></div><div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div><span class="post-meta-divider">|</span><div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.2.0</div></div></footer></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script src="/blog/lib/jquery/index.js?v=3.4.1"></script><script src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/blog/js/utils.js?v=7.2.0"></script><script src="/blog/js/motion.js?v=7.2.0"></script><script src="/blog/js/affix.js?v=7.2.0"></script><script src="/blog/js/schemes/pisces.js?v=7.2.0"></script><script src="/blog/js/scrollspy.js?v=7.2.0"></script><script src="/blog/js/post-details.js?v=7.2.0"></script><script src="/blog/js/next-boot.js?v=7.2.0"></script><script>function loadCount(){var d=document,n=d.createElement("script");n.src="https://yunpeng.disqus.com/count.js",n.id="dsq-count-scr",(d.head||d.body).appendChild(n)}window.addEventListener("load",loadCount,!1)</script><script>var disqus_config=function(){this.page.url="https://yunpengn.github.io/blog/2018/12/22/literature-review-join-reorder/",this.page.identifier="2018/12/22/literature-review-join-reorder/",this.page.title="Literature Review on Join Reorderability"};function loadComments(){var e=document,t=e.createElement("script");t.src="https://yunpeng.disqus.com/embed.js",t.setAttribute("data-timestamp",""+ +new Date),(e.head||e.body).appendChild(t)}window.addEventListener("load",loadComments,!1)</script></body></html>