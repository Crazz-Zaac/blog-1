<!DOCTYPE html><html class="theme-next gemini use-motion" lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><link rel="stylesheet" href="/blog/lib/font-awesome/css/font-awesome.min.css?v=4.7.0"><link rel="stylesheet" href="/blog/css/main.css?v=7.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/blog/images/favicon/apple-touch-icon.png?v=7.2.0"><link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon/favicon-32x32.png?v=7.2.0"><link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon/favicon-16x16.png?v=7.2.0"><link rel="mask-icon" href="/blog/images/favicon/safari_pinned_tab.svg?v=7.2.0" color="#222"><meta name="msapplication-config" content="/blog/images/favicon/browserconfig.xml"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/blog/",scheme:"Gemini",version:"7.2.0",sidebar:{position:"left",display:"post",offset:12,onmobile:!1},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},copycode:{enable:!0,show_result:!1,style:null},fancybox:!1,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},translation:{copy_button:"Copy",copy_success:"Copied",copy_failure:"Copy failed"}}</script><meta name="description" content="Nowadays, Redis has become one of the most popular cache solution in the Internet industry. Although relational database systems (SQL) bring many awesome properties such as ACID, the performance of th"><meta name="keywords" content="Niu,Yunpeng,NUS,CS,Software,Developer"><meta property="og:type" content="article"><meta property="og:title" content="Consistency between Redis Cache and SQL Database"><meta property="og:url" content="https://yunpengn.github.io/blog/2019/05/04/consistent-redis-sql/index.html"><meta property="og:site_name" content="Yunpeng&#39;s Blog"><meta property="og:description" content="Nowadays, Redis has become one of the most popular cache solution in the Internet industry. Although relational database systems (SQL) bring many awesome properties such as ACID, the performance of th"><meta property="og:locale" content="en"><meta property="og:image" content="https://yunpengn.github.io/blog/images/ram_cost.png"><meta property="og:image" content="https://yunpengn.github.io/blog/images/cache_aside_1.png"><meta property="og:image" content="https://yunpengn.github.io/blog/images/cache_aside_2.png"><meta property="og:image" content="https://yunpengn.github.io/blog/images/redis_mysql_hierarchy.png"><meta property="og:updated_time" content="2019-07-13T09:42:23.412Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Consistency between Redis Cache and SQL Database"><meta name="twitter:description" content="Nowadays, Redis has become one of the most popular cache solution in the Internet industry. Although relational database systems (SQL) bring many awesome properties such as ACID, the performance of th"><meta name="twitter:image" content="https://yunpengn.github.io/blog/images/ram_cost.png"><link rel="alternate" href="/blog/atom.xml" title="Yunpeng's Blog" type="application/atom+xml"><link rel="canonical" href="https://yunpengn.github.io/blog/2019/05/04/consistent-redis-sql/"><script id="page.configurations">CONFIG.page={sidebar:""}</script><title>Consistency between Redis Cache and SQL Database | Yunpeng's Blog</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-92228484-1"></script><script>var host=window.location.hostname;if("localhost"!==host){function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-92228484-1")}</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="en"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/blog/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Yunpeng's Blog</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">Life, coding and everything</p></div><div class="site-nav-toggle"><button aria-label="Toggle navigation bar"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-categories"><a href="/blog/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>Categories</a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a></li><li class="menu-item menu-item-about"><a href="/blog/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>About</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://yunpengn.github.io/blog/blog/2019/05/04/consistent-redis-sql/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Niu Yunpeng"><meta itemprop="description" content="The world never stops for you."><meta itemprop="image" content="/blog/images/avatar_cropped.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Yunpeng's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Consistency between Redis Cache and SQL Database</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-05-04 17:02:18" itemprop="dateCreated datePublished" datetime="2019-05-04T17:02:18+08:00">2019-05-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">Edited on</span> <time title="Modified: 2019-07-13 17:42:23" itemprop="dateModified" datetime="2019-07-13T17:42:23+08:00">2019-07-13</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/Technical/" itemprop="url" rel="index"><span itemprop="name">Technical</span></a></span> , <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/Technical/Database/" itemprop="url" rel="index"><span itemprop="name">Database</span></a></span> , <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/Technical/Database/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">Comments: </span><a href="/blog/2019/05/04/consistent-redis-sql/#comments" itemprop="discussionUrl"><span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/05/04/consistent-redis-sql/" itemprop="commentCount"></span></a></span><br></div></header><div class="post-body" itemprop="articleBody"><p>Nowadays, Redis has become one of the most popular cache solution in the Internet industry. Although relational database systems (SQL) bring many awesome properties such as ACID, the performance of the database would degrade under high load in order to maintain these properties.</p><p>In order to fix this problem, many companies &amp; websites have decided to add a cache layer between the application layer (i.e., the backend code which handles the business logic) and the storage layer (i.e., the SQL database). This cache layer is usually implemented using an in-memory cache. This is because, as stated in many textbooks, the performance bottleneck of traditional SQL databases is usually I/O to secondary storage (i.e., the hard disk). As the price of main memory (RAM) has gone down in the past decade, it is now feasible to store (at least part of) the data in main memory to improve performance. One popular choice is Redis.</p><img src="/blog/images/ram_cost.png" width="370" title="The cost of RAM in the past decades"><a id="more"></a><p>Certainly, most systems would only store the <em>so-called</em> “hot data” in the cache layer (i.e., main memory). This is according to the <strong>Pareto Principle</strong> (also known as <strong>80/20 rule</strong>), <em>for many events, roughly 80% of the effects come from 20% of the causes</em>. To be cost-efficient, we just need to store that <em>20%</em> in the cache layer. To identify the “hot data”, we could specify an <em>eviction policy</em> (such as LFU or LRU) to determine which data to expire.</p><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>As mentioned earlier, part of the data from the SQL database would be stored in in-memory cache such as Redis. Even though the performance is improved, this approach brings a huge headache that we do not have a <em>single source of truth</em> anymore. Now, the same peace of data would be stored in two places. How can we ensure the consistency between the data stored in Redis and the data stored in SQL database?</p><p>Below, we present a few common mistakes and point out what could go wrong. We also present a few solutions to this tricky problem.</p><p><em>Notice:</em> to ease our discussion here, we take the example of Redis and traditional SQL database. However, please be aware the solutions presented in this post could be extended to other databases, or even the consistency between any two layers in the memory hierarchy.</p><h2 id="Various-Solutions"><a href="#Various-Solutions" class="headerlink" title="Various Solutions"></a>Various Solutions</h2><p>Below we describe a few approaches to this problem. Most of them are <em>almost correct (but still wrong)</em>. In other words, they can guarantee consistency between the 2 layers 99.9% of the time. However, things could go wrong (such as dirty data in cache) under very high concurrency and huge traffic.</p><p>However, these <em>almost correct</em> solutions are heavily used in the industry and many companies have been using these approaches for years without major headache. Sometimes, going from 99.9% correctness to 100% correctness is too challenging. For real-world business, faster development lifecycle and shorter go-to-market timeline are probably more important.</p><h3 id="Cache-Expiry"><a href="#Cache-Expiry" class="headerlink" title="Cache Expiry"></a>Cache Expiry</h3><p>Some naive solutions try to use cache expiry or retention policy to handle consistency between MySQL and Redis. Although it is a good practice in general to carefully set expiry time and retention policy for your Redis Cluster, this is a terrible solution to guarantee consistency. Let’s say your cache expiry time is 30 minutes. Are you sure you can undertake the danger of reading dirty data for up to half an hour?</p><p>What about setting the expiry time to be shorter? Let’s say we set it to be 1 minute. Unfortunately, we are talking about services with huge traffic and high concurrency here. 60 seconds may make us lose millions of dollars.</p><p>Hmm, let’s set it to be even shorter, what about 5 seconds? Well, you have indeed shortened the inconsistent period. However, you have defeated the original objective of using cache! You will have a lot of cache misses and likely the performance of the system will degrade a lot.</p><h3 id="Cache-Aside"><a href="#Cache-Aside" class="headerlink" title="Cache Aside"></a>Cache Aside</h3><p>The algorithm for cache aside pattern is:</p><ul><li><strong>For immutable operations (read):</strong><ul><li><em>Cache hit:</em> return data from Redis directly, with no query to MySQL;</li><li><em>Cache miss:</em> query MySQL to get the data <em>(can use read replicas to improve performance)</em>, save the returned data to Redis, return the result to client.</li></ul></li><li><strong>For mutable operations (create, update, delete):</strong><ul><li>Create, update or delete the data to MySQL;</li><li>Delete the entry in Redis <em>(always delete rather than update the cache, the new value will be inserted when next cache miss)</em>.</li></ul></li></ul><img src="/blog/images/cache_aside_1.png" width="600" title="Cache Aside Algorithm"> <img src="/blog/images/cache_aside_2.png" width="600" title="Cache Aside Algorithm"><p>This approach would mostly work for common use cases. In fact, cache aside is the de facto standard for implementing consistency between MySQL and Redis. The famous paper, <em>Scaling Memecache at Facebook</em> also described such an approach. However, there does exist some problems with this apporach as well:</p><ul><li>Under normal scenarios (let’s say we assume the process is never killed and write to MySQL/Redis will never fail), it can mostly guarantee <em>eventual consistency</em>. Let’s say process <code>A</code> tries to update an existing value. At a certain moment, <code>A</code> has successfully updated the value in MySQL. Before it deletes the entry in Redis, another process <code>B</code> tries to read the same value. <code>B</code> will then get a cache hit (because the entry has not been deleted in Redis yet). Therefore, <code>B</code> will read the outdated value. However, the old entry in Redis will eventually be deleted and other processes will eventually get the updated value.</li><li>Under extreme situations, it cannot guarantee <em>eventual consistency</em> as well. Let’s consider the same scenario. If process <code>A</code> is killed before it attempts to delete the entry in Redis, that old entry will never be deleted. Hence, all other processes thereafter will keep reading the old value.</li><li>Even under normal scenarios, there exists a corner case with very low probability where <em>eventual consistency</em> may break. Let’s say process <code>C</code> tries to read a value and gets a cache miss. Then <code>C</code> queries MySQL and gets the returned result. Suddenly, <code>C</code> somehow is stuck and paused by the OS for a while. At this moment, another process <code>D</code> tries to update the same value. <code>D</code> updates MySQL and has deleted the entry in Redis. After that, <code>C</code> resumes and saves its query result into Redis. Hence, <code>C</code> saves the old value into Redis and all subsequent processes will read dirty data. This may sound scary, but its probability is very low because:<ul><li>If <code>D</code> is trying to update an existing value, this entry by right should exist in Redis when <code>C</code> tries to read it. This scenario will not happen if <code>C</code> gets a cache hit. In order for such a case to happen, that entry must have expired and been deleted from Redis. However, if this entry is “very hot” (i.e., there is huge read traffic on it), it should have been saved into Redis again very soon after it is expired. If this belongs to “cold data”, there should be low consistency on it and thus it is rare to have one read request and one update request on this entry simultaneously.</li><li>Mostly, writing to Redis should be much faster than writing to MySQL. In reality, <code>C</code>‘s write operation on Redis should happen much earlier than <code>D</code>‘s delete operation on Redis.</li></ul></li></ul><h3 id="Cache-Aside-Variant-1"><a href="#Cache-Aside-Variant-1" class="headerlink" title="Cache Aside - Variant 1"></a>Cache Aside - Variant 1</h3><p>The algorithm for the 1st variant of cache aside pattern is:</p><ul><li><strong>For immutable operations (read):</strong><ul><li><em>Cache hit:</em> return data from Redis directly, with no query to MySQL;</li><li><em>Cache miss:</em> query MySQL to get the data <em>(can use read replicas to improve performance)</em>, save the returned data to Redis, return the result to client.</li></ul></li><li><strong>For mutable operations (create, update, delete):</strong><ul><li>Delete the entry in Redis;</li><li>Create, update or delete the data to MySQL.</li></ul></li></ul><p>This can be a very bad solution. Let’s say process <code>A</code> tries to update an existing value. At a certain moment, <code>A</code> has successfully deleted the entry in Redis. Before <code>A</code> updates the value in MySQL, process <code>B</code> attempts to read the same value and gets a cache miss. Then, <code>B</code> queries MySQL and saves the returned data to Redis. Notice the data in MySQl has not been updated at this moment yet. Since <code>A</code> will not delete the Redis entry again later, the old value will remain in Redis and all subsequent reads to this value will be wrong.</p><p>According to the analysis above, assuming extreme conditions will not happen, both the origin cache aside algorithm and its variant 1 cannot guarantee eventual consistency in some cases (we call such cases the <code>unhappy path</code>). However, the probability of the unhappy path for variant 1 is much higher than that of the original algorithm.</p><h3 id="Cache-Aside-Variant-2"><a href="#Cache-Aside-Variant-2" class="headerlink" title="Cache Aside - Variant 2"></a>Cache Aside - Variant 2</h3><p>The algorithm for the 2nd variant of cache aside pattern is:</p><ul><li><strong>For immutable operations (read):</strong><ul><li><em>Cache hit:</em> return data from Redis directly, with no query to MySQL;</li><li><em>Cache miss:</em> query MySQL to get the data <em>(can use read replicas to improve performance)</em>, save the returned data to Redis, return the result to client.</li></ul></li><li><strong>For mutable operations (create, update, delete):</strong><ul><li>Create, update or delete the data to MySQL;</li><li>Create, update or delete the entry in Redis.</li></ul></li></ul><p>This is a bad solution as well. Let’s say there are two processes <code>A</code> and <code>B</code> both attempting to update an existing value. <code>A</code> updates MySQL before <code>B</code>; however, <code>B</code> updates the Redis entry before <code>A</code>. Eventually, the value in MySQL is updated by <code>B</code>; however, the value in Redis is updated by <code>A</code>. This would cause inconsistency.</p><p>Similarly, the probability of unhappy path for variant 2 is much higher than that of the original approach.</p><h3 id="Read-Through"><a href="#Read-Through" class="headerlink" title="Read Through"></a>Read Through</h3><p>The algorithm for read through pattern is:</p><ul><li><strong>For immutable operations (read):</strong><ul><li>Client will always simply read from cache. Either <em>cache hit</em> or <em>cache miss</em> is transparent to the client. If it is a cache miss, the cache should have the ability to automatically fetch from the database.</li></ul></li><li><strong>For mutable operations (create, update, delete):</strong><ul><li>This strategy does not handle mutable operations. It should be combined with write through (or write behind) pattern.</li></ul></li></ul><p>A key drawback of read through pattern is that many cache layers may not support it. For example, Redis would not be able to fetch from MySQL automatically (unless you write a plugin for Redis).</p><h3 id="Write-Through"><a href="#Write-Through" class="headerlink" title="Write Through"></a>Write Through</h3><p>The algorithm for write through pattern is:</p><ul><li><strong>For immutable operations (read):</strong><ul><li>This strategy does not handle immutable operations. It should be combined with read through pattern.</li></ul></li><li><strong>For mutable operations (create, update, delete):</strong><ul><li>The client only needs to create, update or delete the entry in Redis. The cache layer has to atomically synchronize this change to MySQL.</li></ul></li></ul><p>The drawbacks of write through pattern are obvious as well. First, many cache layers would not natively support this. Second, Redis is a cache rather than an RDBMS. It is not designed to be resilient. Thus, changes may be lost before they are replicated to MySQL. Even if Redis has now supported persistence techniques such as RDB and AOF, this approach is still not recommended.</p><h3 id="Write-Behind"><a href="#Write-Behind" class="headerlink" title="Write Behind"></a>Write Behind</h3><p>The algorithm for write behind pattern is:</p><ul><li><strong>For immutable operations (read):</strong><ul><li>This strategy does not handle immutable operations. It should be combined with read through pattern.</li></ul></li><li><strong>For mutable operations (create, update, delete):</strong><ul><li>The client only needs to create, update or delete the entry in Redis. The cache layer saves the change into a message queue and returns success to the client. The change is replicated to MySQL asynchronously and may happen after Redis sends success response to the client.</li></ul></li></ul><p>Write behind pattern is different from write through because it replicates the changes to MySQL asynchronously. It improves the throughput because the client does not have to wait for the replication to happen. A message queue with high durability could be a possible implementation. Redis stream <em>(supported since Redis 5.0)</em> could be a good option. To further improve the performance, it is possible to combine the changes and update MySQL in batch (to save the number of queries).</p><p>The drawbacks of write behind pattern are similar. First, many cache layers do not natively support this. Second, the message queue used must be FIFO (first in first out). Otherwise, the updates to MySQL may be out of order and thus the eventual result may be incorrect.</p><h3 id="Double-Delete"><a href="#Double-Delete" class="headerlink" title="Double Delete"></a>Double Delete</h3><p>The algorithm for double delete pattern is:</p><ul><li><strong>For immutable operations (read):</strong><ul><li><em>Cache hit:</em> return data from Redis directly, with no query to MySQL;</li><li><em>Cache miss:</em> query MySQL to get the data <em>(can use read replicas to improve performance)</em>, save the returned data to Redis, return the result to client.</li></ul></li><li><strong>For mutable operations (create, update, delete):</strong><ul><li>Delete the entry in Redis;</li><li>Create, update or delete the data to MySQL;</li><li>Sleep for a while (such as 500ms);</li><li>Delete the entry in Redis again.</li></ul></li></ul><p>This approach combines the original cache aside algorithm and its 1st variant. Since it is an improvement based on the original cache aside approach, we can declare that it mostly guarantees <em>eventual consistency</em> under normal scenarios. It has attempted to fix the <code>unhappy path</code> of both approaches as well.</p><p>By pausing the process for 500ms, the algorithm assumes all concurrent read processes have saved the old value into Redis and thus the 2nd delete operation on Redis will clear all dirty data. Although there does still exist a corner case where this algorithm to break eventual consistency, the probability of that would be negligible.</p><h3 id="Write-Behind-Variant"><a href="#Write-Behind-Variant" class="headerlink" title="Write Behind - Variant"></a>Write Behind - Variant</h3><p>In the end, we present a novel approach introduced by the <a href="https://github.com/alibaba/canal" target="_blank" rel="noopener">canal</a> project developed by <a href="https://www.alibabagroup.com/" target="_blank" rel="noopener">Alibaba Group</a> from China.</p><p>This new method can be considered as a variant of the <a href="#Write-Behind">write behind</a> algorithm. However, it performs replication in the other direction. Rather than replicating changes from Redis to MySQL, it subscribes to the <a href="https://dev.mysql.com/doc/refman/8.0/en/binary-log.html" target="_blank" rel="noopener">binlog</a> of MySQL and replicates it to Redis. This provides much better durability and consistency than the original algorithm. Since binlog is part of the RDMS technology, we can assume it is durable and resilient under disaster. Such an architecture is also quite mature as it has been used to replicate changes between MySQL master and slaves.</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>In conclusion, none of the approaches above can guarantee <em>strong consistency</em>. Strong consistency may not be a realistic requirement for the consistency between Redis and MySQL as well. To guarantee strong consistency, we have to implement ACID on all operations. Doing so will degrade the performance of the cache layer, which will defeat our objectives of using Redis cache.</p><p>However, all the approaches above have attempted to achieve <em>eventual consistency</em>, of which the last one (introduced by <a href="https://github.com/alibaba/canal" target="_blank" rel="noopener">canal</a>) being the best. Some of the algorithms above are improvements to some others. To describe their hierarchy, the following tree diagram is drawn. In the diagram, each node would in general achieve better consistency that its children (if any).</p><img src="/blog/images/redis_mysql_hierarchy.png" width="600" title="Hierarchy Diagram of Consistency between MySQL and Redis"><p>We conclude there would always be a tradeoff between 100% correctness and performance. Sometimes, 99.9% correctness is already enough for real-world use cases. In future researches, we remind that people should remeber to not defeat the original objectives of the topic. For example, we cannot sacrifice performance when discussing the consistency between MySQL and Redis.</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final170_update.pdf" target="_blank" rel="noopener">Scaling Memcache at Facebook</a></li><li><a href="http://simongui.github.io/2016/12/02/improving-cache-consistency.html" target="_blank" rel="noopener">Improve Cache Consistency</a></li><li><a href="https://www.quora.com/Why-does-Facebook-use-delete-to-remove-the-key-value-pair-in-Memcached-instead-of-updating-the-Memcached-during-write-request-to-the-backend" target="_blank" rel="noopener">Why does Facebook Use Delete to Remove the Key-value Pair in Memcache Instead of Updating Memcache?</a></li></ul></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>Niu Yunpeng</li><li class="post-copyright-link"><strong>Post link: </strong><a href="https://yunpengn.github.io/blog/2019/05/04/consistent-redis-sql/" title="Consistency between Redis Cache and SQL Database">https://yunpengn.github.io/blog/2019/05/04/consistent-redis-sql/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-ND</a> unless stating additionally.</li></ul></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/blog/2019/02/07/how-query-optimizer-works/" rel="next" title="How Query Optimizer Works in RDBMS"><i class="fa fa-chevron-left"></i> How Query Optimizer Works in RDBMS</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/blog/2019/06/15/aws-certificate-guide/" rel="prev" title="Introducing your Guide to be AWS Certified">Introducing your Guide to be AWS Certified <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div><div class="comments" id="comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">Table of Contents</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">Overview</li></ul><div class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/blog/images/avatar_cropped.jpg" alt="Niu Yunpeng"><p class="site-author-name" itemprop="name">Niu Yunpeng</p><div class="site-description motion-element" itemprop="description">The world never stops for you.</div></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/blog/archives/"><span class="site-state-item-count">11</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/blog/categories/"><span class="site-state-item-count">8</span> <span class="site-state-item-name">categories</span></a></div></nav><div class="feed-link motion-element"><a href="/blog/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/yunpengn" title="GitHub &rarr; https://github.com/yunpengn" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://www.facebook.com/NeilNiuYunpeng" title="Facebook &rarr; https://www.facebook.com/NeilNiuYunpeng" rel="noopener" target="_blank"><i class="fa fa-fw fa-facebook"></i>Facebook</a> </span><span class="links-of-author-item"><a href="https://sg.linkedin.com/in/yunpeng-niu/en" title="LinkedIn &rarr; https://sg.linkedin.com/in/yunpeng-niu/en" rel="noopener" target="_blank"><i class="fa fa-fw fa-linkedin"></i>LinkedIn</a> </span><span class="links-of-author-item"><a href="https://yunpengn.github.io/" title="Website &rarr; https://yunpengn.github.io/"><i class="fa fa-fw fa-globe"></i>Website</a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/blog/images/cc-by-nc-nd.svg" alt="Creative Commons"></a></div></div></div><div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Background"><span class="nav-number">1.</span> <span class="nav-text">Background</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Various-Solutions"><span class="nav-number">2.</span> <span class="nav-text">Various Solutions</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Cache-Expiry"><span class="nav-number">2.1.</span> <span class="nav-text">Cache Expiry</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cache-Aside"><span class="nav-number">2.2.</span> <span class="nav-text">Cache Aside</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cache-Aside-Variant-1"><span class="nav-number">2.3.</span> <span class="nav-text">Cache Aside - Variant 1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cache-Aside-Variant-2"><span class="nav-number">2.4.</span> <span class="nav-text">Cache Aside - Variant 2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Read-Through"><span class="nav-number">2.5.</span> <span class="nav-text">Read Through</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Write-Through"><span class="nav-number">2.6.</span> <span class="nav-text">Write Through</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Write-Behind"><span class="nav-number">2.7.</span> <span class="nav-text">Write Behind</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Double-Delete"><span class="nav-number">2.8.</span> <span class="nav-text">Double Delete</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Write-Behind-Variant"><span class="nav-number">2.9.</span> <span class="nav-text">Write Behind - Variant</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Conclusion"><span class="nav-number">3.</span> <span class="nav-text">Conclusion</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#References"><span class="nav-number">4.</span> <span class="nav-text">References</span></a></li></ol></div></div></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2017 – <span itemprop="copyrightYear">2019</span> <span class="with-love" id="animate"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder"><a href="https://yunpengn.github.io/" class="theme-link" rel="author" target="_blank">Niu Yunpeng</a></span></div><div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div><span class="post-meta-divider">|</span><div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.2.0</div></div></footer></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script src="/blog/lib/jquery/index.js?v=3.4.1"></script><script src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/blog/js/utils.js?v=7.2.0"></script><script src="/blog/js/motion.js?v=7.2.0"></script><script src="/blog/js/affix.js?v=7.2.0"></script><script src="/blog/js/schemes/pisces.js?v=7.2.0"></script><script src="/blog/js/scrollspy.js?v=7.2.0"></script><script src="/blog/js/post-details.js?v=7.2.0"></script><script src="/blog/js/next-boot.js?v=7.2.0"></script><script>function loadCount(){var d=document,n=d.createElement("script");n.src="https://yunpeng.disqus.com/count.js",n.id="dsq-count-scr",(d.head||d.body).appendChild(n)}window.addEventListener("load",loadCount,!1)</script><script>var disqus_config=function(){this.page.url="https://yunpengn.github.io/blog/2019/05/04/consistent-redis-sql/",this.page.identifier="2019/05/04/consistent-redis-sql/",this.page.title="Consistency between Redis Cache and SQL Database"};function loadComments(){var e=document,t=e.createElement("script");t.src="https://yunpeng.disqus.com/embed.js",t.setAttribute("data-timestamp",""+ +new Date),(e.head||e.body).appendChild(t)}window.addEventListener("load",loadComments,!1)</script></body></html>